package grpc

import (
	"context"
	"fmt"
	"net"
	"time"

	"github.com/rusgainew/tunduck-app-mk/auth-service/internal/application/dto"
	"github.com/rusgainew/tunduck-app-mk/auth-service/internal/application/service"
	"github.com/rusgainew/tunduck-app-mk/auth-service/internal/domain/repository"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// AuthServiceServer - gRPC server for AuthService
type AuthServiceServer struct {
	registerService *service.RegisterUserService
	loginService    *service.LoginUserService
	tokenService    *service.TokenService
	userRepo        repository.UserRepository
	tokenBlacklist  repository.TokenBlacklist
}

// NewAuthServiceServer - Factory
func NewAuthServiceServer(
	registerService *service.RegisterUserService,
	loginService *service.LoginUserService,
	tokenService *service.TokenService,
	userRepo repository.UserRepository,
	tokenBlacklist repository.TokenBlacklist,
) *AuthServiceServer {
	return &AuthServiceServer{
		registerService: registerService,
		loginService:    loginService,
		tokenService:    tokenService,
		userRepo:        userRepo,
		tokenBlacklist:  tokenBlacklist,
	}
}

// Register - Register a new user
// Request: email, password, first_name, last_name
// Response: user, token
func (s *AuthServiceServer) Register(ctx context.Context, req *RegisterRequest) (*AuthResponse, error) {
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be nil")
	}

	if req.Email == "" || req.Password == "" {
		return nil, status.Error(codes.InvalidArgument, "email and password are required")
	}

	// Use HTTP DTO for business logic
	registerReq := &dto.RegisterRequest{
		Email:    req.Email,
		Name:     fmt.Sprintf("%s %s", req.FirstName, req.LastName),
		Password: req.Password,
	}

	resp, err := s.registerService.Execute(ctx, registerReq)
	if err != nil {
		return nil, status.Error(codes.Internal, err.Error())
	}

	// Convert to gRPC response
	return &AuthResponse{
		User: &User{
			Id:    resp.ID,
			Email: resp.Email,
			Name:  resp.Name,
		},
		Token: &Token{
			AccessToken:  "", // Will be generated by login
			RefreshToken: "",
			ExpiresIn:    0,
		},
		Timestamp: time.Now().Unix(),
	}, nil
}

// Login - Login existing user
// Request: email, password
// Response: user, token
func (s *AuthServiceServer) Login(ctx context.Context, req *LoginRequest) (*AuthResponse, error) {
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be nil")
	}

	if req.Email == "" || req.Password == "" {
		return nil, status.Error(codes.InvalidArgument, "email and password are required")
	}

	// Use HTTP DTO for business logic
	loginReq := &dto.LoginRequest{
		Email:    req.Email,
		Password: req.Password,
	}

	tokenResp, err := s.loginService.Execute(ctx, loginReq)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, err.Error())
	}

	// Get user
	user, err := s.userRepo.GetUserByEmail(ctx, req.Email)
	if err != nil {
		return nil, status.Error(codes.NotFound, "user not found")
	}

	return &AuthResponse{
		User: &User{
			Id:    user.ID,
			Email: user.Email,
			Name:  user.Name,
		},
		Token: &Token{
			AccessToken:  tokenResp.AccessToken,
			RefreshToken: tokenResp.RefreshToken,
			ExpiresIn:    tokenResp.ExpiresIn,
		},
		Timestamp: time.Now().Unix(),
	}, nil
}

// ValidateToken - Validate access token and get user info
// Request: access_token
// Response: user
// Used by other services to verify JWT tokens
func (s *AuthServiceServer) ValidateToken(ctx context.Context, req *ValidateTokenRequest) (*User, error) {
	if req == nil || req.AccessToken == "" {
		return nil, status.Error(codes.InvalidArgument, "access_token is required")
	}

	// Validate token
	userID, err := s.tokenService.ValidateToken(ctx, req.AccessToken)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "invalid or expired token")
	}

	// Get user
	user, err := s.userRepo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, status.Error(codes.NotFound, "user not found")
	}

	return &User{
		Id:    user.ID,
		Email: user.Email,
		Name:  user.Name,
	}, nil
}

// GetUser - Get user by ID
// Request: user_id
// Response: user
func (s *AuthServiceServer) GetUser(ctx context.Context, req *GetUserRequest) (*User, error) {
	if req == nil || req.UserId == "" {
		return nil, status.Error(codes.InvalidArgument, "user_id is required")
	}

	user, err := s.userRepo.GetUserByID(ctx, req.UserId)
	if err != nil {
		return nil, status.Error(codes.NotFound, "user not found")
	}

	return &User{
		Id:    user.ID,
		Email: user.Email,
		Name:  user.Name,
	}, nil
}

// Logout - Logout user (invalidate token)
// Request: access_token
// Response: empty
func (s *AuthServiceServer) Logout(ctx context.Context, req *LogoutRequest) (*Empty, error) {
	if req == nil || req.AccessToken == "" {
		return nil, status.Error(codes.InvalidArgument, "access_token is required")
	}

	// Validate token first
	_, err := s.tokenService.ValidateToken(ctx, req.AccessToken)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "invalid token")
	}

	// Add to blacklist (will expire automatically)
	expiresIn := s.tokenService.GetJWTManager().GetExpiresIn()
	if err := s.tokenBlacklist.AddToBlacklist(ctx, req.AccessToken, expiresIn); err != nil {
		return nil, status.Error(codes.Internal, "failed to logout")
	}

	return &Empty{}, nil
}

// RefreshToken - Refresh access token
// Request: refresh_token
// Response: new_token
func (s *AuthServiceServer) RefreshToken(ctx context.Context, req *RefreshTokenRequest) (*Token, error) {
	if req == nil || req.RefreshToken == "" {
		return nil, status.Error(codes.InvalidArgument, "refresh_token is required")
	}

	// Validate refresh token
	userID, err := s.tokenService.ValidateRefreshToken(ctx, req.RefreshToken)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "invalid or expired refresh token")
	}

	// Get user to get email
	user, err := s.userRepo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, status.Error(codes.NotFound, "user not found")
	}

	// Generate new access token
	tokenResp, err := s.tokenService.GenerateTokens(ctx, user.ID, user.Email)
	if err != nil {
		return nil, status.Error(codes.Internal, "failed to generate new token")
	}

	return &Token{
		AccessToken:  tokenResp.AccessToken,
		RefreshToken: tokenResp.RefreshToken,
		ExpiresIn:    tokenResp.ExpiresIn,
	}, nil
}

// gRPC Server wrapper for starting the service
type GRPCServer struct {
	server *grpc.Server
	addr   string
}

// NewGRPCServer - Factory
func NewGRPCServer(addr string, authServiceServer *AuthServiceServer) *GRPCServer {
	server := grpc.NewServer()
	// Register auth service
	RegisterAuthService(server, authServiceServer)

	return &GRPCServer{
		server: server,
		addr:   addr,
	}
}

// Start - Start gRPC server
func (s *GRPCServer) Start() error {
	listener, err := net.Listen("tcp", s.addr)
	if err != nil {
		return fmt.Errorf("failed to listen on %s: %w", s.addr, err)
	}

	fmt.Printf("Starting gRPC server on %s\n", s.addr)
	return s.server.Serve(listener)
}

// Stop - Stop gRPC server gracefully
func (s *GRPCServer) Stop() {
	s.server.GracefulStop()
}

// ====================================
// Placeholder message types
// These would be generated from proto files
// ====================================

type RegisterRequest struct {
	Email     string
	Password  string
	FirstName string
	LastName  string
}

type LoginRequest struct {
	Email    string
	Password string
}

type AuthResponse struct {
	User      *User
	Token     *Token
	Timestamp int64
}

type ValidateTokenRequest struct {
	AccessToken string
}

type GetUserRequest struct {
	UserId string
}

type LogoutRequest struct {
	AccessToken string
}

type RefreshTokenRequest struct {
	RefreshToken string
}

type User struct {
	Id    string
	Email string
	Name  string
}

type Token struct {
	AccessToken  string
	RefreshToken string
	ExpiresIn    int64
}

type Empty struct {
}

// RegisterAuthService - Register handler with gRPC server
func RegisterAuthService(server *grpc.Server, handler *AuthServiceServer) {
	// This would be generated by protoc
	// For now, we're implementing the business logic that would be called
}
