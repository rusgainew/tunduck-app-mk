// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: entities/invoice_detail.proto

package entities

import (
	dictionaries "github.com/rusgainew/tunduck-app-mk/proto-lib/dictionaries"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// InvoiceDetail представляет одну строку (позицию) в счете-фактуре.
// Содержит информацию о конкретном товаре или услуге, включаемой в счет.
//
// Каждая строка описывает:
//   - Наименование товара/услуги
//   - Количество и цену
//   - Суммы без налога, с налогом, налоговые суммы
//   - Классификацию по кодам ТНВЭД/ГКЭД
//   - Применяемые налоги (НДС, НСП)
//
// Структура позволяет правильно рассчитать и отобразить все компоненты
// стоимости товара/услуги в соответствии с налоговым законодательством.
type InvoiceDetail struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID - Уникальный идентификатор строки детали в системе.
	// Первичный ключ для этой позиции в счете.
	// Генерируется системой при создании.
	// Пример: 1, 2, 3 (порядковые номера строк в счете)
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// InvoiceUUID - UUID счета-фактуры, к которому относится эта строка.
	// Позволяет связать деталь с конкретным счетом.
	// Пример: "550e8400-e29b-41d4-a716-446655440000"
	InvoiceUuid string `protobuf:"bytes,2,opt,name=invoice_uuid,json=invoiceUuid,proto3" json:"invoice_uuid,omitempty"`
	// BaseCount - Количество товара/услуги в базовых единицах измерения.
	// Число единиц, которые продаются/покупаются (могут быть дробные значения).
	// Пример: 5.5 (пять с половиной единиц товара)
	BaseCount float64 `protobuf:"fixed64,3,opt,name=base_count,json=baseCount,proto3" json:"base_count,omitempty"`
	// Price - Цена одной единицы товара/услуги (за базовую единицу).
	// Базовая стоимость товара без налогов (обычно без НДС и НСП).
	// Используется для расчета всех остальных сумм.
	// Пример: 1000.00 (один товар стоит 1000 сомов)
	Price float64 `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
	// Amount - Общая стоимость товара (цена × количество).
	// Базовая сумма без учета налогов: Amount = BaseCount × Price
	// Пример: 5500.00 (если BaseCount=5.5, Price=1000)
	Amount float64 `protobuf:"fixed64,5,opt,name=amount,proto3" json:"amount,omitempty"`
	// AmountWithoutVAT - Сумма стоимости товара без НДС.
	// Может совпадать с Amount, если НДС не применяется или применяется налог на добавленную стоимость.
	// Используется для отображения в счете "Сумма без НДС".
	// Пример: 4910.71 (если от базовой суммы вычтен НДС)
	AmountWithoutVat float64 `protobuf:"fixed64,6,opt,name=amount_without_vat,json=amountWithoutVat,proto3" json:"amount_without_vat,omitempty"`
	// AmountVAT - Сумма налога на добавленную стоимость (НДС).
	// Размер налога, который добавляется к базовой стоимости.
	// Рассчитывается как: AmountVAT = Amount × (ставка НДС / 100)
	// Пример: 589.29 (если ставка НДС 12% от суммы 4910.71)
	AmountVat float64 `protobuf:"fixed64,7,opt,name=amount_vat,json=amountVat,proto3" json:"amount_vat,omitempty"`
	// AmountST - Сумма налога НСП (налог с продаж).
	// Дополнительный налог, применяемый к некоторым товарам/услугам.
	// Рассчитывается отдельно от НДС по своей ставке.
	// Пример: 0.00 (если НСП не применяется к этому товару)
	AmountSt float64 `protobuf:"fixed64,8,opt,name=amount_st,json=amountSt,proto3" json:"amount_st,omitempty"`
	// GoodsName - Полное наименование товара или оказываемой услуги.
	// Описание товара, как его воспринимает конечный пользователь.
	// Должно быть четким и полным для идентификации товара.
	// Примеры: "Портативный компьютер ASUS VivoBook 15", "Услуга консультирования, 8 часов"
	GoodsName string `protobuf:"bytes,9,opt,name=goods_name,json=goodsName,proto3" json:"goods_name,omitempty"`
	// TNVEDCode - Код ТНВЭД (Таможенная номенклатура внешнеэкономической деятельности).
	// Используется для таможенной классификации товаров при импорте/экспорте.
	// Определяет применимые таможенные пошлины и налоги.
	// Формат: 10 цифр (например, "8471.30.90")
	// Может быть пусто для услуг, оказываемых внутри страны.
	TnvedCode string `protobuf:"bytes,10,opt,name=tnved_code,json=tnvedCode,proto3" json:"tnved_code,omitempty"`
	// GKEDCode - Код ГКЭД (Государственный классификатор видов экономической деятельности).
	// Используется для классификации деятельности, к которой относится товар/услуга.
	// Определяет отраслевую принадлежность операции.
	// Формат: может быть различным в зависимости от классификатора
	// Может быть пусто для некоторых товаров.
	GkedCode string `protobuf:"bytes,11,opt,name=gked_code,json=gkedCode,proto3" json:"gked_code,omitempty"`
	// FCDNumber - Номер ГТД или другого таможенного документа происхождения.
	// Используется для товаров, ввезенных из-за границы, содержит номер их таможенной декларации.
	// Позволяет установить происхождение и таможенный статус товара.
	// Может быть пусто для отечественных товаров.
	// Пример: "КТ 0000001"
	FcdNumber string `protobuf:"bytes,12,opt,name=fcd_number,json=fcdNumber,proto3" json:"fcd_number,omitempty"`
	// UnitClassification - Тип единицы измерения товара/услуги.
	// Определяет, в каких единицах измеряется количество товара.
	// Примеры кодов: "PCS" (штук), "KG" (килограмм), "M" (метр), "HOUR" (часов), "L" (литр)
	// Используется для правильного отображения и интерпретации BaseCount.
	UnitClassification *dictionaries.ReferenceItem `protobuf:"bytes,13,opt,name=unit_classification,json=unitClassification,proto3" json:"unit_classification,omitempty"`
	// GoodsType - Тип товара: товар или услуга.
	// Различение между материальными товарами и нематериальными услугами.
	// Примеры кодов: "GOODS" (товар), "SERVICE" (услуга)
	// Влияет на применимость налогов и способ расчетов.
	GoodsType *dictionaries.ReferenceItem `protobuf:"bytes,14,opt,name=goods_type,json=goodsType,proto3" json:"goods_type,omitempty"`
	// STTaxType - Вид и ставка налога НСП (налог с продаж), если применяется.
	// Содержит информацию о налоговой ставке, которая применяется к этому товару.
	// Может быть nil, если НСП не применяется.
	// Примеры: rate="10%", name="НСП 10%" или rate="0%", name="НСП не применяется"
	StTaxType     *dictionaries.VATTaxType `protobuf:"bytes,15,opt,name=st_tax_type,json=stTaxType,proto3" json:"st_tax_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InvoiceDetail) Reset() {
	*x = InvoiceDetail{}
	mi := &file_entities_invoice_detail_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceDetail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceDetail) ProtoMessage() {}

func (x *InvoiceDetail) ProtoReflect() protoreflect.Message {
	mi := &file_entities_invoice_detail_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceDetail.ProtoReflect.Descriptor instead.
func (*InvoiceDetail) Descriptor() ([]byte, []int) {
	return file_entities_invoice_detail_proto_rawDescGZIP(), []int{0}
}

func (x *InvoiceDetail) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *InvoiceDetail) GetInvoiceUuid() string {
	if x != nil {
		return x.InvoiceUuid
	}
	return ""
}

func (x *InvoiceDetail) GetBaseCount() float64 {
	if x != nil {
		return x.BaseCount
	}
	return 0
}

func (x *InvoiceDetail) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *InvoiceDetail) GetAmount() float64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *InvoiceDetail) GetAmountWithoutVat() float64 {
	if x != nil {
		return x.AmountWithoutVat
	}
	return 0
}

func (x *InvoiceDetail) GetAmountVat() float64 {
	if x != nil {
		return x.AmountVat
	}
	return 0
}

func (x *InvoiceDetail) GetAmountSt() float64 {
	if x != nil {
		return x.AmountSt
	}
	return 0
}

func (x *InvoiceDetail) GetGoodsName() string {
	if x != nil {
		return x.GoodsName
	}
	return ""
}

func (x *InvoiceDetail) GetTnvedCode() string {
	if x != nil {
		return x.TnvedCode
	}
	return ""
}

func (x *InvoiceDetail) GetGkedCode() string {
	if x != nil {
		return x.GkedCode
	}
	return ""
}

func (x *InvoiceDetail) GetFcdNumber() string {
	if x != nil {
		return x.FcdNumber
	}
	return ""
}

func (x *InvoiceDetail) GetUnitClassification() *dictionaries.ReferenceItem {
	if x != nil {
		return x.UnitClassification
	}
	return nil
}

func (x *InvoiceDetail) GetGoodsType() *dictionaries.ReferenceItem {
	if x != nil {
		return x.GoodsType
	}
	return nil
}

func (x *InvoiceDetail) GetStTaxType() *dictionaries.VATTaxType {
	if x != nil {
		return x.StTaxType
	}
	return nil
}

var File_entities_invoice_detail_proto protoreflect.FileDescriptor

const file_entities_invoice_detail_proto_rawDesc = "" +
	"\n" +
	"\x1dentities/invoice_detail.proto\x12\bentities\x1a!dictionaries/reference_item.proto\x1a\x1fdictionaries/vat_tax_type.proto\"\xb7\x04\n" +
	"\rInvoiceDetail\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x03R\x02id\x12!\n" +
	"\finvoice_uuid\x18\x02 \x01(\tR\vinvoiceUuid\x12\x1d\n" +
	"\n" +
	"base_count\x18\x03 \x01(\x01R\tbaseCount\x12\x14\n" +
	"\x05price\x18\x04 \x01(\x01R\x05price\x12\x16\n" +
	"\x06amount\x18\x05 \x01(\x01R\x06amount\x12,\n" +
	"\x12amount_without_vat\x18\x06 \x01(\x01R\x10amountWithoutVat\x12\x1d\n" +
	"\n" +
	"amount_vat\x18\a \x01(\x01R\tamountVat\x12\x1b\n" +
	"\tamount_st\x18\b \x01(\x01R\bamountSt\x12\x1d\n" +
	"\n" +
	"goods_name\x18\t \x01(\tR\tgoodsName\x12\x1d\n" +
	"\n" +
	"tnved_code\x18\n" +
	" \x01(\tR\ttnvedCode\x12\x1b\n" +
	"\tgked_code\x18\v \x01(\tR\bgkedCode\x12\x1d\n" +
	"\n" +
	"fcd_number\x18\f \x01(\tR\tfcdNumber\x12L\n" +
	"\x13unit_classification\x18\r \x01(\v2\x1b.dictionaries.ReferenceItemR\x12unitClassification\x12:\n" +
	"\n" +
	"goods_type\x18\x0e \x01(\v2\x1b.dictionaries.ReferenceItemR\tgoodsType\x128\n" +
	"\vst_tax_type\x18\x0f \x01(\v2\x18.dictionaries.VATTaxTypeR\tstTaxTypeB8Z6github.com/rusgainew/tunduck-app-mk/proto-lib/entitiesb\x06proto3"

var (
	file_entities_invoice_detail_proto_rawDescOnce sync.Once
	file_entities_invoice_detail_proto_rawDescData []byte
)

func file_entities_invoice_detail_proto_rawDescGZIP() []byte {
	file_entities_invoice_detail_proto_rawDescOnce.Do(func() {
		file_entities_invoice_detail_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_entities_invoice_detail_proto_rawDesc), len(file_entities_invoice_detail_proto_rawDesc)))
	})
	return file_entities_invoice_detail_proto_rawDescData
}

var file_entities_invoice_detail_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_entities_invoice_detail_proto_goTypes = []any{
	(*InvoiceDetail)(nil),              // 0: entities.InvoiceDetail
	(*dictionaries.ReferenceItem)(nil), // 1: dictionaries.ReferenceItem
	(*dictionaries.VATTaxType)(nil),    // 2: dictionaries.VATTaxType
}
var file_entities_invoice_detail_proto_depIdxs = []int32{
	1, // 0: entities.InvoiceDetail.unit_classification:type_name -> dictionaries.ReferenceItem
	1, // 1: entities.InvoiceDetail.goods_type:type_name -> dictionaries.ReferenceItem
	2, // 2: entities.InvoiceDetail.st_tax_type:type_name -> dictionaries.VATTaxType
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_entities_invoice_detail_proto_init() }
func file_entities_invoice_detail_proto_init() {
	if File_entities_invoice_detail_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_entities_invoice_detail_proto_rawDesc), len(file_entities_invoice_detail_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_entities_invoice_detail_proto_goTypes,
		DependencyIndexes: file_entities_invoice_detail_proto_depIdxs,
		MessageInfos:      file_entities_invoice_detail_proto_msgTypes,
	}.Build()
	File_entities_invoice_detail_proto = out.File
	file_entities_invoice_detail_proto_goTypes = nil
	file_entities_invoice_detail_proto_depIdxs = nil
}
